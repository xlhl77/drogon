<%inc#include "create_model.h"
using namespace drogon_ctl;
%>
/**
 *
 *  [[className]].cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */

#include "[[className]].h"
#include <drogon/utils/Utilities.h>
#include <string>
<%c++
    auto cols=@@.get<std::vector<ColumnInfo>>("columns");
    auto className=@@.get<std::string>("className");
%>

using namespace drogon;
using namespace drogon_model::[[dbName]];

<%c++for(auto col:cols){
%>
const std::string [[className]]::Cols::{%col._colName%} = "{%col._colName%}";
<%c++
}%>
<%c++if(@@.get<int>("hasPrimaryKey")<=1){%>
const std::string [[className]]::primaryKeyName = "[[primaryKeyName]]";
<%c++}else{%>
const std::vector<std::string> [[className]]::primaryKeyName = {<%c++
auto pkName=@@.get<std::vector<std::string>>("primaryKeyName");
for(size_t i=0;i<pkName.size();i++)
{
    $$<<"\""<<pkName[i]<<"\"";
    if(i<(pkName.size()-1))
        $$<<",";
}
%>};
<%c++}%>
<%c++ if(@@.get<int>("hasPrimaryKey",0)>0){%>
const bool [[className]]::hasPrimaryKey = true;
<%c++ }else{%>
const bool [[className]]::hasPrimaryKey = false;
<%c++}%>
const std::string [[className]]::tableName = "[[tableName]]";

const std::vector<typename [[className]]::MetaData> [[className]]::_metaData={
<%c++for(size_t i=0;i<cols.size();i++){
    auto &col=cols[i];
$$<<"{\""<<col._colName<<"\",\""<<col._colType<<"\",\""<<col._colDatabaseType<<"\","<<col._colLength<<","<<col._isAutoVal<<","<<col._isPrimaryKey<<","<<col._notNull<<"}";
if(i<(cols.size()-1))
$$<<",\n";
else
$$<<"\n";
}%>
};
const std::string &[[className]]::getColumnName(size_t index) noexcept(false)
{
    assert(index < _metaData.size());
    return _metaData[index]._colName;
}
[[className]]::[[className]](const Row &r) noexcept
{
<%c++
    for(auto col:cols)
    {
        if(col._colType.empty())
            continue;
        %>
        if(!r["{%col._colName%}"].isNull())
        {
<%c++
            if(col._colDatabaseType=="date")
            {
                $$<<"            auto daysStr = r[\""<<col._colName<<"\"].as<std::string>();\n";
                $$<<"            struct tm stm;\n";
                $$<<"            memset(&stm,0,sizeof(stm));\n";
                $$<<"            strptime(daysStr.c_str(),\"%Y-%m-%d\",&stm);\n";
                $$<<"            long t = timelocal(&stm);\n";
 //               $$<<"            _"<<col._colValName<<"=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                $$<<"            _"<<col._colValName<<"=std::make_shared<::trantor::Date>(t*1000000);\n";
                $$<<"        }\n";
                continue;
            }
            else if(col._colDatabaseType.find("timestamp")!=std::string::npos||col._colDatabaseType.find("datetime")!=std::string::npos)
            {
                $$<<"            auto timeStr = r[\""<<col._colName<<"\"].as<std::string>();\n";
                $$<<"            struct tm stm;\n";
                $$<<"            memset(&stm,0,sizeof(stm));\n";
                $$<<"            auto p = strptime(timeStr.c_str(),\"%Y-%m-%d %H:%M:%S\",&stm);\n";
                $$<<"            size_t t = timelocal(&stm);\n";
                $$<<"            size_t decimalNum = 0;\n";
                $$<<"            if(*p=='.')\n";
                $$<<"            {\n";
                $$<<"                std::string decimals(p+1,&timeStr[timeStr.length()]);\n";
                $$<<"                while(decimals.length()<6)\n";
                $$<<"                {\n";
                $$<<"                    decimals += \"0\";\n";
                $$<<"                }\n";
                $$<<"                decimalNum = (size_t)atol(decimals.c_str());\n";
                $$<<"            }\n";
 //               $$<<"            _"<<col._colValName<<"=std::make_shared<::trantor::Date>(::trantor::Date(946656000000000).after(daysNum*86400));\n";
                $$<<"            _"<<col._colValName<<"=std::make_shared<::trantor::Date>(t*1000000+decimalNum);\n";
                $$<<"        }\n";
                continue;
            } 
            else if(col._colDatabaseType=="bytea")
            {
                $$<<"            auto str = r[\""<<col._colName<<"\"].as<string_view>();\n";
                $$<<"            if(str.length()>=2&&\n";
                $$<<"               str[0]=='\\\\'&&str[1]=='x')\n";
                $$<<"            {\n";
                $$<<"                _"<<col._colValName<<"=std::make_shared<std::vector<char>>(drogon::utils::hexToBinaryVector(str.data()+2,str.length()-2));\n";
                $$<<"            }\n";
                $$<<"        }\n";
                continue;
            }           
%>
            _{%col._colValName%}=std::make_shared<{%col._colType%}>(r["{%col._colName%}"].as<{%col._colType%}>());
        }
<%c++
    }
    %>
}
<%c++
    for(size_t i=0;i<cols.size();i++)
    {
        auto & col = cols[i];
        if(!col._colType.empty())
        {
            $$<<"const "<<col._colType<<" &"<<className<<"::getValueOf"<<col._colTypeName<<"(const "<<col._colType<<" &defaultValue) const noexcept\n";
            $$<<"{\n";
            $$<<"    if(_"<<col._colValName<<")\n";
            $$<<"        return *_"<<col._colValName<<";\n";
            $$<<"    return defaultValue;\n";
            $$<<"}\n";
            if(col._colType=="std::vector<char>")
            {
                $$<<"std::string "<<className<<"::getValueOf"<<col._colTypeName<<"AsString(const std::string &defaultValue) const noexcept\n";
                $$<<"{\n";
                $$<<"    if(_"<<col._colValName<<")\n";
                $$<<"        return std::string(_"<<col._colValName<<"->data(),_"<<col._colValName<<"->size());\n";
                $$<<"    return defaultValue;\n";
                $$<<"}\n";
            }
            $$<<"std::shared_ptr<const "<<col._colType<<"> "<<className<<"::get"<<col._colTypeName<<"() const noexcept\n";
            $$<<"{\n";
            $$<<"    return _"<<col._colValName<<";\n";
            $$<<"}\n";
 
            if(!col._isAutoVal)
            {
                $$<<"void "<<className<<"::set"<<col._colTypeName<<"(const "<<col._colType<<" &"<<col._colValName<<") noexcept\n";
                $$<<"{\n";
                if(col._colDatabaseType=="date")
                {
                    $$<<"    _"<<col._colValName<<" = std::make_shared<"<<col._colType<<">("<<col._colValName<<".roundDay());\n";
                }
                else
                {
                    $$<<"    _"<<col._colValName<<" = std::make_shared<"<<col._colType<<">("<<col._colValName<<");\n";
                }
                $$<<"    _dirtyFlag["<<i<<"] = true;\n";
                $$<<"}\n";
                
                if(col._colType=="std::string")
                {
                    $$<<"void "<<className<<"::set"<<col._colTypeName<<"("<<col._colType<<" &&"<<col._colValName<<") noexcept\n";
                    $$<<"{\n";
                    $$<<"    _"<<col._colValName<<" = std::make_shared<"<<col._colType<<">(std::move("<<col._colValName<<"));\n";
                    $$<<"    _dirtyFlag["<<i<<"] = true;\n";
                    $$<<"}\n";
                }

                if(col._colType=="std::vector<char>")
                {
                    $$<<"void "<<className<<"::set"<<col._colTypeName<<"(const std::string &"<<col._colValName<<") noexcept\n";
                    $$<<"{\n";
                    $$<<"    _"<<col._colValName<<" = std::make_shared<std::vector<char>>("<<col._colValName<<".c_str(),"<<col._colValName<<".c_str()+"<<col._colValName<<".length());\n";
                    $$<<"    _dirtyFlag["<<i<<"] = true;\n";
                    $$<<"}\n";
                }
            }
            if(col._isPrimaryKey&&@@.get<int>("hasPrimaryKey")==1)
            {
                $$<<"const typename "<<className<<"::PrimaryKeyType & "<<className<<"::getPrimaryKey() const\n";
                $$<<"{\n";
                $$<<"    assert(_"<<col._colValName<<");\n";
                $$<<"    return *_"<<col._colValName<<";\n";
                $$<<"}\n";
            }
        }
        $$<<"\n";    
    }
    if(@@.get<std::string>("rdbms")=="postgresql")
    {
        $$<<"void "<<className<<"::updateId(const uint64_t id)\n";
        $$<<"{\n";
        $$<<"}\n";
    }
    else if(@@.get<std::string>("rdbms")=="mysql"||@@.get<std::string>("rdbms")=="sqlite3")
    {
        $$<<"void "<<className<<"::updateId(const uint64_t id)\n";
        $$<<"{\n";
        for(auto col:cols)
        {
            if(col._isAutoVal)
            {
                $$<<"    _"<<col._colValName<<" = std::make_shared<uint64_t>(id);\n";
                break;
            }
        }
        $$<<"}\n";
    }
    if(@@.get<int>("hasPrimaryKey")>1)
    {
        $$<<"typename "<<className<<"::PrimaryKeyType "<<className<<"::getPrimaryKey() const\n";
        $$<<"{\n";
        $$<<"    return std::make_tuple(";
        int count=0;
        for(auto col:cols)
        {
            if(col._isPrimaryKey)
            {
                count++;
                $$<<"*_"<<col._colValName;
                if(count<@@.get<int>("hasPrimaryKey"))
                    $$<<",";
            }
        }
        $$<<");\n";
        $$<<"}\n";
    }
%>

const std::vector<std::string> &[[className]]::insertColumns() noexcept
{
    static const std::vector<std::string> _inCols={
<%c++for(size_t i=0;i<cols.size();i++){
    auto col=cols[i];
    if(!col._isAutoVal&&!col._colType.empty())
    {
        $$<<"        \""<<col._colName<<"\"";
        if(i<(cols.size()-1))
            $$<<",\n";
        else
            $$<<"\n";
    }
}%>
    };
    return _inCols;
}

void [[className]]::outputArgs(drogon::orm::internal::SqlBinder &binder) const
{
<%c++for(auto col:cols){
    if(!col._isAutoVal&&!col._colType.empty())
    {
%>
    if(get{%col._colTypeName%}())
    {
        binder << getValueOf{%col._colTypeName%}();
    }
    else
    {
        binder << nullptr;
    }
<%c++
    }
}
%>
}

const std::vector<std::string> [[className]]::updateColumns() const
{
    std::vector<std::string> ret;
    for(size_t i=0;i<sizeof(_dirtyFlag);i++)
    {
        if(_dirtyFlag[i])
        {
            ret.push_back(getColumnName(i));
        }
    }
    return ret;
}

void [[className]]::updateArgs(drogon::orm::internal::SqlBinder &binder) const
{
<%c++
    for(size_t i=0;i<cols.size();i++)
    {
        auto & col=cols[i];
        if(col._colType.empty()||col._isAutoVal)
            continue;
%>
    if(_dirtyFlag[{%i%}])
    {
        if(get{%col._colTypeName%}())
        {
            binder << getValueOf{%col._colTypeName%}();
        }
        else
        {
            binder << nullptr;
        }
    }
<%c++
    }
%>
}
Json::Value [[className]]::toJson() const
{
    Json::Value ret;
<%c++for(auto col:cols){%>
    if(get{%col._colTypeName%}())
    {
<%c++if(col._colDatabaseType=="date"){%>
        ret["{%col._colName%}"]=get{%col._colTypeName%}()->toDbStringLocal();
<%c++}else if(col._colDatabaseType.find("timestamp")!=std::string::npos||col._colDatabaseType.find("datetime")!=std::string::npos){%>
        ret["{%col._colName%}"]=get{%col._colTypeName%}()->toDbStringLocal();
<%c++}else if(col._colDatabaseType=="bytea"||col._colDatabaseType.find("blob")!=std::string::npos){%>
        ret["{%col._colName%}"]=drogon::utils::base64Encode((const unsigned char *)get{%col._colTypeName%}()->data(),get{%col._colTypeName%}()->size());
<%c++}else if(col._colType=="int64_t"){%>
        ret["{%col._colName%}"]=(Json::Int64)getValueOf{%col._colTypeName%}();
<%c++}else if(col._colType=="uint64_t"){%>
        ret["{%col._colName%}"]=(Json::UInt64)getValueOf{%col._colTypeName%}();
<%c++}else{%>
        ret["{%col._colName%}"]=getValueOf{%col._colTypeName%}();
<%c++}%>
    }
    else
    {
        ret["{%col._colName%}"]=Json::Value();
    }
<%c++
}%>
    return ret;
}
