/**
 *
 *  Groups.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */

#include "Groups.h"
#include <drogon/utils/Utilities.h>
#include <string>

using namespace drogon_model::sqlite3;

const std::string Groups::Cols::group_id = "group_id";
const std::string Groups::Cols::group_name = "group_name";
const std::string Groups::Cols::creater_id = "creater_id";
const std::string Groups::Cols::create_time = "create_time";
const std::string Groups::Cols::inviting = "inviting";
const std::string Groups::Cols::inviting_user_id = "inviting_user_id";
const std::string Groups::Cols::avatar_id = "avatar_id";
const std::string Groups::Cols::uuu = "uuu";
const std::string Groups::Cols::text = "text";
const std::string Groups::Cols::avatar = "avatar";
const std::string Groups::primaryKeyName = "group_id";
const bool Groups::hasPrimaryKey = true;
const std::string Groups::tableName = "GROUPS";

const std::vector<typename Groups::MetaData> Groups::_metaData = {
    {"group_id", "uint64_t", "integer", 8, 1, 1, 0},
    {"group_name", "std::string", "text", 0, 0, 0, 0},
    {"creater_id", "uint64_t", "integer", 8, 0, 0, 0},
    {"create_time", "std::string", "text", 0, 0, 0, 0},
    {"inviting", "uint64_t", "integer", 8, 0, 0, 0},
    {"inviting_user_id", "uint64_t", "integer", 8, 0, 0, 0},
    {"avatar_id", "std::string", "text", 0, 0, 0, 0},
    {"uuu", "double", "double", 8, 0, 0, 0},
    {"text", "std::string", "varchar(255)", 0, 0, 0, 0},
    {"avatar", "std::vector<char>", "blob", 0, 0, 0, 0}};
const std::string &Groups::getColumnName(size_t index) noexcept(false)
{
    assert(index < _metaData.size());
    return _metaData[index]._colName;
}
Groups::Groups(const Row &r) noexcept
{
    if (!r["group_id"].isNull())
    {
        _groupId = std::make_shared<uint64_t>(r["group_id"].as<uint64_t>());
    }
    if (!r["group_name"].isNull())
    {
        _groupName =
            std::make_shared<std::string>(r["group_name"].as<std::string>());
    }
    if (!r["creater_id"].isNull())
    {
        _createrId = std::make_shared<uint64_t>(r["creater_id"].as<uint64_t>());
    }
    if (!r["create_time"].isNull())
    {
        _createTime =
            std::make_shared<std::string>(r["create_time"].as<std::string>());
    }
    if (!r["inviting"].isNull())
    {
        _inviting = std::make_shared<uint64_t>(r["inviting"].as<uint64_t>());
    }
    if (!r["inviting_user_id"].isNull())
    {
        _invitingUserId =
            std::make_shared<uint64_t>(r["inviting_user_id"].as<uint64_t>());
    }
    if (!r["avatar_id"].isNull())
    {
        _avatarId =
            std::make_shared<std::string>(r["avatar_id"].as<std::string>());
    }
    if (!r["uuu"].isNull())
    {
        _uuu = std::make_shared<double>(r["uuu"].as<double>());
    }
    if (!r["text"].isNull())
    {
        _text = std::make_shared<std::string>(r["text"].as<std::string>());
    }
    if (!r["avatar"].isNull())
    {
        _avatar = std::make_shared<std::vector<char>>(
            r["avatar"].as<std::vector<char>>());
    }
}
const uint64_t &Groups::getValueOfGroupId(const uint64_t &defaultValue) const
    noexcept
{
    if (_groupId)
        return *_groupId;
    return defaultValue;
}
std::shared_ptr<const uint64_t> Groups::getGroupId() const noexcept
{
    return _groupId;
}
const typename Groups::PrimaryKeyType &Groups::getPrimaryKey() const
{
    assert(_groupId);
    return *_groupId;
}

const std::string &Groups::getValueOfGroupName(
    const std::string &defaultValue) const noexcept
{
    if (_groupName)
        return *_groupName;
    return defaultValue;
}
std::shared_ptr<const std::string> Groups::getGroupName() const noexcept
{
    return _groupName;
}
void Groups::setGroupName(const std::string &groupName) noexcept
{
    _groupName = std::make_shared<std::string>(groupName);
    _dirtyFlag[1] = true;
}
void Groups::setGroupName(std::string &&groupName) noexcept
{
    _groupName = std::make_shared<std::string>(std::move(groupName));
    _dirtyFlag[1] = true;
}

const uint64_t &Groups::getValueOfCreaterId(const uint64_t &defaultValue) const
    noexcept
{
    if (_createrId)
        return *_createrId;
    return defaultValue;
}
std::shared_ptr<const uint64_t> Groups::getCreaterId() const noexcept
{
    return _createrId;
}
void Groups::setCreaterId(const uint64_t &createrId) noexcept
{
    _createrId = std::make_shared<uint64_t>(createrId);
    _dirtyFlag[2] = true;
}

const std::string &Groups::getValueOfCreateTime(
    const std::string &defaultValue) const noexcept
{
    if (_createTime)
        return *_createTime;
    return defaultValue;
}
std::shared_ptr<const std::string> Groups::getCreateTime() const noexcept
{
    return _createTime;
}
void Groups::setCreateTime(const std::string &createTime) noexcept
{
    _createTime = std::make_shared<std::string>(createTime);
    _dirtyFlag[3] = true;
}
void Groups::setCreateTime(std::string &&createTime) noexcept
{
    _createTime = std::make_shared<std::string>(std::move(createTime));
    _dirtyFlag[3] = true;
}

const uint64_t &Groups::getValueOfInviting(const uint64_t &defaultValue) const
    noexcept
{
    if (_inviting)
        return *_inviting;
    return defaultValue;
}
std::shared_ptr<const uint64_t> Groups::getInviting() const noexcept
{
    return _inviting;
}
void Groups::setInviting(const uint64_t &inviting) noexcept
{
    _inviting = std::make_shared<uint64_t>(inviting);
    _dirtyFlag[4] = true;
}

const uint64_t &Groups::getValueOfInvitingUserId(
    const uint64_t &defaultValue) const noexcept
{
    if (_invitingUserId)
        return *_invitingUserId;
    return defaultValue;
}
std::shared_ptr<const uint64_t> Groups::getInvitingUserId() const noexcept
{
    return _invitingUserId;
}
void Groups::setInvitingUserId(const uint64_t &invitingUserId) noexcept
{
    _invitingUserId = std::make_shared<uint64_t>(invitingUserId);
    _dirtyFlag[5] = true;
}

const std::string &Groups::getValueOfAvatarId(
    const std::string &defaultValue) const noexcept
{
    if (_avatarId)
        return *_avatarId;
    return defaultValue;
}
std::shared_ptr<const std::string> Groups::getAvatarId() const noexcept
{
    return _avatarId;
}
void Groups::setAvatarId(const std::string &avatarId) noexcept
{
    _avatarId = std::make_shared<std::string>(avatarId);
    _dirtyFlag[6] = true;
}
void Groups::setAvatarId(std::string &&avatarId) noexcept
{
    _avatarId = std::make_shared<std::string>(std::move(avatarId));
    _dirtyFlag[6] = true;
}

const double &Groups::getValueOfUuu(const double &defaultValue) const noexcept
{
    if (_uuu)
        return *_uuu;
    return defaultValue;
}
std::shared_ptr<const double> Groups::getUuu() const noexcept
{
    return _uuu;
}
void Groups::setUuu(const double &uuu) noexcept
{
    _uuu = std::make_shared<double>(uuu);
    _dirtyFlag[7] = true;
}

const std::string &Groups::getValueOfText(const std::string &defaultValue) const
    noexcept
{
    if (_text)
        return *_text;
    return defaultValue;
}
std::shared_ptr<const std::string> Groups::getText() const noexcept
{
    return _text;
}
void Groups::setText(const std::string &text) noexcept
{
    _text = std::make_shared<std::string>(text);
    _dirtyFlag[8] = true;
}
void Groups::setText(std::string &&text) noexcept
{
    _text = std::make_shared<std::string>(std::move(text));
    _dirtyFlag[8] = true;
}

const std::vector<char> &Groups::getValueOfAvatar(
    const std::vector<char> &defaultValue) const noexcept
{
    if (_avatar)
        return *_avatar;
    return defaultValue;
}
std::string Groups::getValueOfAvatarAsString(
    const std::string &defaultValue) const noexcept
{
    if (_avatar)
        return std::string(_avatar->data(), _avatar->size());
    return defaultValue;
}
std::shared_ptr<const std::vector<char>> Groups::getAvatar() const noexcept
{
    return _avatar;
}
void Groups::setAvatar(const std::vector<char> &avatar) noexcept
{
    _avatar = std::make_shared<std::vector<char>>(avatar);
    _dirtyFlag[9] = true;
}

void Groups::setAvatar(const std::string &avatar) noexcept
{
    _avatar =
        std::make_shared<std::vector<char>>(avatar.c_str(),
                                            avatar.c_str() + avatar.length());
    _dirtyFlag[9] = true;
}

void Groups::updateId(const uint64_t id)
{
    _groupId = std::make_shared<uint64_t>(id);
}

const std::vector<std::string> &Groups::insertColumns() noexcept
{
    static const std::vector<std::string> _inCols = {"group_name",
                                                     "creater_id",
                                                     "create_time",
                                                     "inviting",
                                                     "inviting_user_id",
                                                     "avatar_id",
                                                     "uuu",
                                                     "text",
                                                     "avatar"};
    return _inCols;
}

void Groups::outputArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if (getGroupName())
    {
        binder << getValueOfGroupName();
    }
    else
    {
        binder << nullptr;
    }
    if (getCreaterId())
    {
        binder << getValueOfCreaterId();
    }
    else
    {
        binder << nullptr;
    }
    if (getCreateTime())
    {
        binder << getValueOfCreateTime();
    }
    else
    {
        binder << nullptr;
    }
    if (getInviting())
    {
        binder << getValueOfInviting();
    }
    else
    {
        binder << nullptr;
    }
    if (getInvitingUserId())
    {
        binder << getValueOfInvitingUserId();
    }
    else
    {
        binder << nullptr;
    }
    if (getAvatarId())
    {
        binder << getValueOfAvatarId();
    }
    else
    {
        binder << nullptr;
    }
    if (getUuu())
    {
        binder << getValueOfUuu();
    }
    else
    {
        binder << nullptr;
    }
    if (getText())
    {
        binder << getValueOfText();
    }
    else
    {
        binder << nullptr;
    }
    if (getAvatar())
    {
        binder << getValueOfAvatar();
    }
    else
    {
        binder << nullptr;
    }
}

const std::vector<std::string> Groups::updateColumns() const
{
    std::vector<std::string> ret;
    for (size_t i = 0; i < sizeof(_dirtyFlag); i++)
    {
        if (_dirtyFlag[i])
        {
            ret.push_back(getColumnName(i));
        }
    }
    return ret;
}

void Groups::updateArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if (_dirtyFlag[1])
    {
        if (getGroupName())
        {
            binder << getValueOfGroupName();
        }
        else
        {
            binder << nullptr;
        }
    }
    if (_dirtyFlag[2])
    {
        if (getCreaterId())
        {
            binder << getValueOfCreaterId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if (_dirtyFlag[3])
    {
        if (getCreateTime())
        {
            binder << getValueOfCreateTime();
        }
        else
        {
            binder << nullptr;
        }
    }
    if (_dirtyFlag[4])
    {
        if (getInviting())
        {
            binder << getValueOfInviting();
        }
        else
        {
            binder << nullptr;
        }
    }
    if (_dirtyFlag[5])
    {
        if (getInvitingUserId())
        {
            binder << getValueOfInvitingUserId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if (_dirtyFlag[6])
    {
        if (getAvatarId())
        {
            binder << getValueOfAvatarId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if (_dirtyFlag[7])
    {
        if (getUuu())
        {
            binder << getValueOfUuu();
        }
        else
        {
            binder << nullptr;
        }
    }
    if (_dirtyFlag[8])
    {
        if (getText())
        {
            binder << getValueOfText();
        }
        else
        {
            binder << nullptr;
        }
    }
    if (_dirtyFlag[9])
    {
        if (getAvatar())
        {
            binder << getValueOfAvatar();
        }
        else
        {
            binder << nullptr;
        }
    }
}
Json::Value Groups::toJson() const
{
    Json::Value ret;
    if (getGroupId())
    {
        ret["group_id"] = (Json::UInt64)getValueOfGroupId();
    }
    else
    {
        ret["group_id"] = Json::Value();
    }
    if (getGroupName())
    {
        ret["group_name"] = getValueOfGroupName();
    }
    else
    {
        ret["group_name"] = Json::Value();
    }
    if (getCreaterId())
    {
        ret["creater_id"] = (Json::UInt64)getValueOfCreaterId();
    }
    else
    {
        ret["creater_id"] = Json::Value();
    }
    if (getCreateTime())
    {
        ret["create_time"] = getValueOfCreateTime();
    }
    else
    {
        ret["create_time"] = Json::Value();
    }
    if (getInviting())
    {
        ret["inviting"] = (Json::UInt64)getValueOfInviting();
    }
    else
    {
        ret["inviting"] = Json::Value();
    }
    if (getInvitingUserId())
    {
        ret["inviting_user_id"] = (Json::UInt64)getValueOfInvitingUserId();
    }
    else
    {
        ret["inviting_user_id"] = Json::Value();
    }
    if (getAvatarId())
    {
        ret["avatar_id"] = getValueOfAvatarId();
    }
    else
    {
        ret["avatar_id"] = Json::Value();
    }
    if (getUuu())
    {
        ret["uuu"] = getValueOfUuu();
    }
    else
    {
        ret["uuu"] = Json::Value();
    }
    if (getText())
    {
        ret["text"] = getValueOfText();
    }
    else
    {
        ret["text"] = Json::Value();
    }
    if (getAvatar())
    {
        ret["avatar"] = drogon::utils::base64Encode(
            (const unsigned char *)getAvatar()->data(), getAvatar()->size());
    }
    else
    {
        ret["avatar"] = Json::Value();
    }
    return ret;
}
